# 의존성
- B가 변경(클래스이름 등)될 때 A도 변경됨
- B가 변경되었다고 무조건 A에 영향을 미치지 않음
- A는 B에 의존하고 있다

## 클래스 의존성
1. A -> B = Association 연관관계(영구적인 경로)
```java
class A {
    private B b;
}
```

2. A --> B = Dependency 의존관계(파라미터, 리턴타입, 객체생성 등)(일시적인 경로)
```java
class A {
    public B method(B b) {
        return new B();
    }
}
```

3. A -> B = Inheritance 상속관계(구현이 바끼면 영향을 끼침)
```java
class A extends B {
}
```

4. A --> B = Realization 실체화관계(interface의 operation 시그니처가 변경될 경우 영향을 끼침)
```java
class A implements B {
}
```

## 패키지 의존성
- 패키지에 포함된 클래스 사이의 의존성
- import에 따른 패키지의 이름이 나오면 의존성이 있다고 보면 됨

## 의존성 설계시 주의사항(의존성 관리의 원칙)
### 양방향 의존성을 피하라
- 양방향(Bi-Directional) = 성능 이슈, 싱크 맞춤 등
```java
class A {
    private B b;
    
    public void setA(B b) {
        this.b = b;
        this.b.setA(this);
    }
}

class B {
    private A a;
    
    public void setA(A a) {
        this.a = a;
    }
}
```

- 단방향(Uni-Directional)
```java
class A {
    private B b;
    public void setA(B b) {
        this.b = b
    }
}

class B{
}
```

### 다중성이 적은 방향을 선택하라
- 다대다(OneToMany) = 성능 이슈, 관리하기 어려움 등
```java
class A {
    private Collection<B> bs;
}

class B{
}
```

- 다대일(ManyToOne)
```java
class A{
}

class B {
    private A a;
}
```

### 의존성이 필요없다면 제거하라
- 단방향(Uni-Directional)
```java
class A {
    private B b;
}

class B{
}
```

- 없음(None)
```java
class A {
}

class B{
}
```

### 패키지 사이의 의존성 사이클을 제거하라
- 설계는 코드를 배치하는 데 어떻게 바뀔지에 대해 초점을 맞춰야됨
- 의존성이 순환참조가 일어나면 그것들은 원래 하나의 패키지일 가능성이 높음

## 관계에는 방향성이 필요
- 관계의 방향 = 협력의 방향 = 의존성의 방향

## 관게의 종류 결정하기
- 연관관계 = 협력을 위해 필요한 영구적인 탐색구조, 빈번하게 소통하는 관계(객체참조)
- 의존관계 = 협력을 위해 일시적으로 필요한 의존성(파라미터, 리턴타입, 지연변수)
- 방향성이 중요함
- 런타임이 어떻게 객체랑 협력하냐가 중요함

## 연관관계 = 탐색가능성(navigability)
- Order에서 OrderLineItem으로 탐색가능
- Order가 뭔지 알면 Order를 통해 원하는 OrderLineItem을 찾을 수 있음
- 두 객체 사이에 협력이 필요하고 두 객체의 관계가 영구적이라면 연관관계를 이용해 탐색 경로 구현
```java
class Order {
    private Long id;
    private Shop shop;
    private List<OrderLineItem> orderLineItems; // 객체 참조

    public void place() { // 메시지를 결정하고 메서드를 만들어야 함
        validate();
        ordered();
    }

    private void validate() {
        for(OrderLineItem orderLineItem : orderLineItems) {
            orderLineItem.validate(); // 연관관계를 통해 협력
        }
    }

    private void ordered() {
    }
}
```