# 의존성
- B가 변경(클래스이름 등)될 때 A도 변경됨
- B가 변경되었다고 무조건 A에 영향을 미치지 않음
- A는 B에 의존하고 있다

## 클래스 의존성
1. A -> B = Association 연관관계(영구적인 경로)
```java
class A {
    private B b;
}
```

2. A --> B = Dependency 의존관계(파라미터, 리턴타입, 객체생성 등)(일시적인 경로)
```java
class A {
    public B method(B b) {
        return new B();
    }
}
```

3. A -> B = Inheritance 상속관계(구현이 바끼면 영향을 끼침)
```java
class A extends B {
}
```

4. A --> B = Realization 실체화관계(interface의 operation 시그니처가 변경될 경우 영향을 끼침)
```java
class A implements B {
}
```

## 패키지 의존성
- 패키지에 포함된 클래스 사이의 의존성
- import에 따른 패키지의 이름이 나오면 의존성이 있다고 보면 됨

## 의존성 설계시 주의사항(의존성 관리의 원칙)
### 양방향 의존성을 피하라
- 양방향(Bi-Directional) = 성능 이슈, 싱크 맞춤 등
```java
class A {
    private B b;
    
    public void setA(B b) {
        this.b = b;
        this.b.setA(this);
    }
}

class B {
    private A a;
    
    public void setA(A a) {
        this.a = a;
    }
}
```

- 단방향(Uni-Directional)
```java
class A {
    private B b;
    public void setA(B b) {
        this.b = b
    }
}

class B{
}
```

### 다중성이 적은 방향을 선택하라
- 다대다(OneToMany)
    - 성능 이슈, 관리하기 어려움 등
```java
class A {
    private Collection<B> bs;
}

class B{
}
```
- 다대일(ManyToOne)
```java
class A{
}

class B {
    private A a;
}
```

### 의존성이 필요없다면 제거하라
- 단방향(Uni-Directional)
```java
class A {
    private B b;
}

class B{
}
```
- 없음(None)
```java
class A {
}

class B{
}
```

### 패키지 사이의 의존성 사이클을 제거하라
- 설계는 코드를 배치하는 데 어떻게 바뀔지에 대해 초점을 맞춰야됨
- 의존성이 순환참조가 일어나면 그것들은 원래 하나의 패키지일 가능성이 높음